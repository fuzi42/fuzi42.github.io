{"title":"React学习（1）","date":"2019-10-08T01:31:45.005Z","link":"2019/10/08/React学习（1）","updated":"2019-10-08T01:31:58.482Z","content":"<h3 id=\"展示组件-amp-容器组件\">展示组件 &amp; 容器组件<a href=\"2019/10/08/React学习（1）#展示组件-amp-容器组件\"></a></h3><p>写React应用时，我发现了一种简单而有效的模式。如果你也写过一阵子React，或许你也已经发现它了。对于这种模式我还想再补充几点。</p>\n<p>如果把组件 <strong>分为以下两类</strong>，对组件的复用和理解会更容易一些。我这两类组件称为 <em>展示组件</em>和<em>容器组件</em>。也有叫“胖的&amp;瘦的”、“聪明的&amp;笨的”、“包含状态的的&amp;纯的”、“Screens and Components”的等等说法，这些说法并不完全一致，但核心理念大概相同。</p>\n<h3 id=\"展示组件的特性：\">展示组件的特性：<a href=\"2019/10/08/React学习（1）#展示组件的特性：\"></a></h3><ul>\n<li>负责<em>外观</em>的展示</li>\n<li>可能同时包含展示组件 &amp; 容器组件，通常带有自身的 DOM标签 和 样式属性</li>\n<li>通常可以通过 <code>this.props.children</code> 包含组件</li>\n<li>不依赖应用中的其他组件，如FLUX的 actions 或 stores</li>\n<li>对于如何加载、修改数据，不做具体规定</li>\n<li>仅通过props来接收数据 和 回调函数</li>\n<li>几乎没有自身的状态（就是有，也是UI状态，而不是数据）</li>\n<li>除非组件需要状态、生命周期钩子(lifecycle hooks)、或者性能优化，否则一般写为函数式组件</li>\n<li>例如 <em>Page, Sidebar, Story, UserInfo, List</em>.</li>\n</ul>\n<h3 id=\"容器组件的特性\">容器组件的特性<a href=\"2019/10/08/React学习（1）#容器组件的特性\"></a></h3><ul>\n<li>负责<em>功能</em>的实现</li>\n<li>可能同时包含展示组件 &amp; 容器组件，但通常自身不带有任何DOM标签（起包裹作用的div除外），也不带有任何样式属性</li>\n<li>向 展示组件 和 其他容器组件 提供数据和行为/方法</li>\n<li>调用Flux的actions，并将其作为回调函数，提供给展示组件</li>\n<li>通常是包含状态的，因为经常把它们作为数据源使用。</li>\n<li>通常不是手写的，而是用高阶组件生成的。高阶组件HOC，如React Redux 的<code>connect()</code> ，Relay的<code>createContainer()</code> 或者 Flux Utils的 <code>Container.create()</code> 等）</li>\n<li>例如：<em>UserPage, FollowersSidebar, StoryContainer, FollowedUserList.</em></li>\n</ul>\n<p>为了让这种区分更加明显，我会把这两类组件放到不同的目录里。</p>\n<h3 id=\"这么做的好处\">这么做的好处<a href=\"2019/10/08/React学习（1）#这么做的好处\"></a></h3><ul>\n<li>两类组件各司其职。由此，你对该APP/UI的理解会更加深入。</li>\n<li>更好的复用性。对完全不同的状态源，你可以使用同一个展示组件，并将其变为不同的、可进一步复用的容器组件。</li>\n<li>展示组件其实就是APP的“调色板”。你可以把它们放到一个单独的页面上，交给设计师，随便他怎么折腾，APP的逻辑和功能都不会受到一丝影响。你可以在这个页面上进行screenshot regression测试。</li>\n<li>迫使你从APP里“提炼”出“布局组件”，如Sidebar, Page, ContextMenu等。由此，你将不得不使用this.props.children，而非在若干容器组件内 重复使用一套布局相关的代码。</li>\n</ul>\n<p><em>请注意，组件并不一定需要生成DOM。They only need to provide composition boundaries between UI concerns.它们只需要提供UI之间的分界与组合关系。</em></p>\n<p>好好利用这一点。</p>\n<h3 id=\"何时引入容器组件？\">何时引入容器组件？<a href=\"2019/10/08/React学习（1）#何时引入容器组件？\"></a></h3><p>在刚开始写APP的时候，我建议你只写展示组件。先就这么写着，总会有一个时刻，你将注意到，有太多的属性需要传递给中间层的组件。有些组件根本用不上这些属性，传给它们的目的，仅仅是为了能继续向下传递属性。而且，当子组件需要更多的数据时，你不得不重写中间层的组件。当你意识到这些时，就是引入容器组件的好时机。通过使用容器组件，无需途径组件树中其他无关的组件，就可以直接将数据和方法属性传给末端的叶子组件中。</p>\n<p>这种重构的过程是渐进的，别想着一步到位。随着你对这种模式日复一日地练习，对于何时使用容器组件，你会慢慢培养出一种直觉。这种感觉就像你知道啥时候应该抽象出函数一样。</p>\n","prev":{"title":"React学习（2）","link":"2019/10/08/React学习（2）"},"next":{"title":"关于React学习","link":"2019/10/02/关于React学习"},"plink":"/2019/10/08/React学习（1）/"}